

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7.8. Filenames and separate compilation &#8212; Glasgow Haskell Compiler 8.5.20180310 User&#39;s Guide</title>
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.5.20180310',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 8.5.20180310 User&#39;s Guide"
          href="_static/opensearch.xml"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7.9. Packages" href="packages.html" />
    <link rel="prev" title="7.7. Running a compiled program" href="runtime_control.html" /> 
  </head>
  <body>
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler User's Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="packages.html" title="7.9. Packages"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="runtime_control.html" title="7.7. Running a compiled program"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.5.20180310 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" accesskey="U">7. Using GHC</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.8. Filenames and separate compilation</a><ul>
<li><a class="reference internal" href="#haskell-source-files">7.8.1. Haskell source files</a></li>
<li><a class="reference internal" href="#output-files">7.8.2. Output files</a></li>
<li><a class="reference internal" href="#the-search-path">7.8.3. The search path</a></li>
<li><a class="reference internal" href="#redirecting-the-compilation-output-s">7.8.4. Redirecting the compilation output(s)</a></li>
<li><a class="reference internal" href="#keeping-intermediate-files">7.8.5. Keeping Intermediate Files</a></li>
<li><a class="reference internal" href="#redirecting-temporary-files">7.8.6. Redirecting temporary files</a></li>
<li><a class="reference internal" href="#other-options-related-to-interface-files">7.8.7. Other options related to interface files</a></li>
<li><a class="reference internal" href="#the-recompilation-checker">7.8.8. The recompilation checker</a></li>
<li><a class="reference internal" href="#how-to-compile-mutually-recursive-modules">7.8.9. How to compile mutually recursive modules</a></li>
<li><a class="reference internal" href="#module-signatures">7.8.10. Module signatures</a></li>
<li><a class="reference internal" href="#using-make">7.8.11. Using <code class="docutils literal"><span class="pre">make</span></code></a></li>
<li><a class="reference internal" href="#dependency-generation">7.8.12. Dependency generation</a></li>
<li><a class="reference internal" href="#orphan-modules-and-instance-declarations">7.8.13. Orphan modules and instance declarations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="runtime_control.html"
                        title="previous chapter">7.7. Running a compiled program</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="packages.html"
                        title="next chapter">7.9. Packages</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/separate_compilation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="filenames-and-separate-compilation">
<span id="separate-compilation"></span><h1>7.8. Filenames and separate compilation<a class="headerlink" href="#filenames-and-separate-compilation" title="Permalink to this headline">¶</a></h1>
<p id="index-0">This section describes what files GHC expects to find, what files it
creates, where these files are stored, and what options affect this
behaviour.</p>
<p>Pathname conventions vary from system to system. In particular, the
directory separator is “<code class="docutils literal"><span class="pre">/</span></code>” on Unix systems and “<code class="docutils literal"><span class="pre">\</span></code>” on
Windows systems. In the sections that follow, we shall consistently use
“<code class="docutils literal"><span class="pre">/</span></code>” as the directory separator; substitute this for the
appropriate character for your system.</p>
<div class="section" id="haskell-source-files">
<span id="source-files"></span><h2>7.8.1. Haskell source files<a class="headerlink" href="#haskell-source-files" title="Permalink to this headline">¶</a></h2>
<p id="index-1">Each Haskell source module should be placed in a file on its own.</p>
<p>Usually, the file should be named after the module name, replacing dots
in the module name by directory separators. For example, on a Unix
system, the module <code class="docutils literal"><span class="pre">A.B.C</span></code> should be placed in the file <code class="docutils literal"><span class="pre">A/B/C.hs</span></code>,
relative to some base directory. If the module is not going to be
imported by another module (<code class="docutils literal"><span class="pre">Main</span></code>, for example), then you are free to
use any filename for it.</p>
<p id="index-2">GHC assumes that source files are ASCII or UTF-8 only, other
encoding are not recognised. However, invalid UTF-8 sequences
will be ignored in comments, so it is possible to use other encodings
such as Latin-1, as long as the non-comment source code is ASCII
only.</p>
</div>
<div class="section" id="output-files">
<span id="id1"></span><h2>7.8.2. Output files<a class="headerlink" href="#output-files" title="Permalink to this headline">¶</a></h2>
<p id="index-3">When asked to compile a source file, GHC normally generates two files:
an object file, and an interface file.</p>
<p>The object file, which normally ends in a <code class="docutils literal"><span class="pre">.o</span></code> suffix, contains the
compiled code for the module.</p>
<p>The interface file, which normally ends in a <code class="docutils literal"><span class="pre">.hi</span></code> suffix, contains the
information that GHC needs in order to compile further modules that depend on
this module. It contains things like the types of exported functions,
definitions of data types, and so on. It is stored in a binary format, so don’t
try to read one; use the <a class="reference internal" href="using.html#ghc-flag---show-iface ⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--show-iface</span> <span class="pre">⟨file⟩</span></code></a> option instead (see
<a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p>
<p>You should think of the object file and the interface file as a pair,
since the interface file is in a sense a compiler-readable description
of the contents of the object file. If the interface file and object
file get out of sync for any reason, then the compiler may end up making
assumptions about the object file that aren’t true; trouble will almost
certainly follow. For this reason, we recommend keeping object files and
interface files in the same place (GHC does this by default, but it is
possible to override the defaults as we’ll explain shortly).</p>
<p>Every module has a <em>module name</em> defined in its source code
(<code class="docutils literal"><span class="pre">module</span> <span class="pre">A.B.C</span> <span class="pre">where</span> <span class="pre">...</span></code>).</p>
<p>The name of the object file generated by GHC is derived according to the
following rules, where ⟨osuf⟩ is the object-file suffix (this can be
changed with the <code class="docutils literal"><span class="pre">-osuf</span></code> option).</p>
<ul class="simple">
<li>If there is no <code class="docutils literal"><span class="pre">-odir</span></code> option (the default), then the object
filename is derived from the source filename (ignoring the module
name) by replacing the suffix with ⟨osuf⟩.</li>
<li>If <code class="docutils literal"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code> has been specified, then the object filename is
⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced
by slashes. GHC will silently create the necessary directory
structure underneath ⟨dir⟩, if it does not already exist.</li>
</ul>
<p>The name of the interface file is derived using the same rules, except that the
suffix is ⟨hisuf⟩ (<code class="docutils literal"><span class="pre">.hi</span></code> by default) instead of ⟨osuf⟩, and the relevant
options are <a class="reference internal" href="#ghc-flag--hidir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-hidir</span> <span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag--hisuf ⟨suffix⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-hisuf</span> <span class="pre">⟨suffix⟩</span></code></a> instead of
<a class="reference internal" href="#ghc-flag--odir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag--osuf ⟨suffix⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-osuf</span> <span class="pre">⟨suffix⟩</span></code></a> respectively.</p>
<p>For example, if GHC compiles the module <code class="docutils literal"><span class="pre">A.B.C</span></code> in the file
<code class="docutils literal"><span class="pre">src/A/B/C.hs</span></code>, with no <code class="docutils literal"><span class="pre">-odir</span></code> or <code class="docutils literal"><span class="pre">-hidir</span></code> flags, the interface
file will be put in <code class="docutils literal"><span class="pre">src/A/B/C.hi</span></code> and the object file in
<code class="docutils literal"><span class="pre">src/A/B/C.o</span></code>.</p>
<p>For any module that is imported, GHC requires that the name of the
module in the import statement exactly matches the name of the module in
the interface file (or source file) found using the strategy specified
in <a class="reference internal" href="#search-path"><span class="std std-ref">The search path</span></a>. This means that for most modules, the source file
name should match the module name.</p>
<p>However, note that it is reasonable to have a module <code class="docutils literal"><span class="pre">Main</span></code> in a file
named <code class="docutils literal"><span class="pre">foo.hs</span></code>, but this only works because GHC never needs to search
for the interface for module <code class="docutils literal"><span class="pre">Main</span></code> (because it is never imported). It
is therefore possible to have several <code class="docutils literal"><span class="pre">Main</span></code> modules in separate
source files in the same directory, and GHC will not get confused.</p>
<p>In batch compilation mode, the name of the object file can also be overridden
using the <a class="reference internal" href="#ghc-flag--o ⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-o</span> <span class="pre">⟨file⟩</span></code></a> option, and the name of the interface file can
be specified directly using the <a class="reference internal" href="#ghc-flag--ohi ⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ohi</span> <span class="pre">⟨file⟩</span></code></a> option.</p>
</div>
<div class="section" id="the-search-path">
<span id="search-path"></span><h2>7.8.3. The search path<a class="headerlink" href="#the-search-path" title="Permalink to this headline">¶</a></h2>
<p id="index-4">In your program, you import a module <code class="docutils literal"><span class="pre">Foo</span></code> by saying <code class="docutils literal"><span class="pre">import</span> <span class="pre">Foo</span></code>.
In <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> mode or GHCi, GHC will look for a source file for <code class="docutils literal"><span class="pre">Foo</span></code>
and arrange to compile it first. Without <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a>, GHC will look for
the interface file for <code class="docutils literal"><span class="pre">Foo</span></code>, which should have been created by an
earlier compilation of <code class="docutils literal"><span class="pre">Foo</span></code>. GHC uses the same strategy in each of
these cases for finding the appropriate file.</p>
<p>This strategy is as follows: GHC keeps a list of directories called the
search path. For each of these directories, it tries appending
<code class="docutils literal"><span class="pre">⟨basename⟩.⟨extension⟩</span></code> to the directory, and checks whether the
file exists. The value of ⟨basename⟩ is the module name with dots
replaced by the directory separator (“<code class="docutils literal"><span class="pre">/</span></code>” or “<code class="docutils literal"><span class="pre">\\&quot;</span></code>, depending on the
system), and ⟨extension⟩ is a source extension (<code class="docutils literal"><span class="pre">hs</span></code>, <code class="docutils literal"><span class="pre">lhs</span></code>) if we
are in <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> mode or GHCi, or ⟨hisuf⟩ otherwise.</p>
<p>For example, suppose the search path contains directories <code class="docutils literal"><span class="pre">d1</span></code>,
<code class="docutils literal"><span class="pre">d2</span></code>, and <code class="docutils literal"><span class="pre">d3</span></code>, and we are in <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> mode looking for the source
file for a module <code class="docutils literal"><span class="pre">A.B.C</span></code>. GHC will look in <code class="docutils literal"><span class="pre">d1/A/B/C.hs</span></code>,
<code class="docutils literal"><span class="pre">d1/A/B/C.lhs</span></code>, <code class="docutils literal"><span class="pre">d2/A/B/C.hs</span></code>, and so on.</p>
<p>The search path by default contains a single directory: “<code class="docutils literal"><span class="pre">.</span></code>” (i.e. the
current directory). The following options can be used to add to or change the
contents of the search path:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--i⟨dir⟩[:⟨dir⟩]*">
<code class="descname">-i⟨dir⟩</code><code class="descclassname">[:⟨dir⟩]*</code><a class="headerlink" href="#ghc-flag--i⟨dir⟩[:⟨dir⟩]*" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-5">This flag appends a colon-separated list of <code class="docutils literal"><span class="pre">dirs</span></code> to
the search path.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--i">
<code class="descname">-i</code><a class="headerlink" href="#ghc-flag--i" title="Permalink to this definition">¶</a></dt>
<dd><p>resets the search path back to nothing.</p>
</dd></dl>

<p>This isn’t the whole story: GHC also looks for modules in pre-compiled
libraries, known as packages. See the section on packages
(<a class="reference internal" href="packages.html#packages"><span class="std std-ref">Packages</span></a>) for details.</p>
</div>
<div class="section" id="redirecting-the-compilation-output-s">
<span id="options-output"></span><h2>7.8.4. Redirecting the compilation output(s)<a class="headerlink" href="#redirecting-the-compilation-output-s" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-6"></span><dl class="ghc-flag">
<dt id="ghc-flag--o ⟨file⟩">
<code class="descname">-o</code><code class="descclassname"> ⟨file⟩</code><a class="headerlink" href="#ghc-flag--o ⟨file⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>GHC’s compiled output normally goes into a <code class="docutils literal"><span class="pre">.hc</span></code>, <code class="docutils literal"><span class="pre">.o</span></code>, etc.,
file, depending on the last-run compilation phase. The option
<code class="docutils literal"><span class="pre">-o</span> <span class="pre">file</span></code> re-directs the output of that last-run phase to ⟨file⟩.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This “feature” can be counterintuitive: <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-C</span> <span class="pre">-o</span> <span class="pre">foo.o</span> <span class="pre">foo.hs</span></code>
will put the intermediate C code in the file <code class="docutils literal"><span class="pre">foo.o</span></code>, name
notwithstanding!</p>
</div>
<p>This option is most often used when creating an executable file, to
set the filename of the executable. For example:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc -o prog --make Main
</pre></div>
</div>
<p>will compile the program starting with module <code class="docutils literal"><span class="pre">Main</span></code> and put the
executable in the file <code class="docutils literal"><span class="pre">prog</span></code>.</p>
<p>Note: on Windows, if the result is an executable file, the extension
“<code class="docutils literal"><span class="pre">.exe</span></code>” is added if the specified filename does not already have
an extension. Thus</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc -o foo Main.hs
</pre></div>
</div>
<p>will compile and link the module <code class="docutils literal"><span class="pre">Main.hs</span></code>, and put the resulting
executable in <code class="docutils literal"><span class="pre">foo.exe</span></code> (not <code class="docutils literal"><span class="pre">foo</span></code>).</p>
<p>If you use <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span></code> and you don’t use the <code class="docutils literal"><span class="pre">-o</span></code>, the name GHC
will choose for the executable will be based on the name of the file
containing the module <code class="docutils literal"><span class="pre">Main</span></code>. Note that with GHC the <code class="docutils literal"><span class="pre">Main</span></code>
module doesn’t have to be put in file <code class="docutils literal"><span class="pre">Main.hs</span></code>. Thus both</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc --make Prog
</pre></div>
</div>
<p>and</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc --make Prog.hs
</pre></div>
</div>
<p>will produce <code class="docutils literal"><span class="pre">Prog</span></code> (or <code class="docutils literal"><span class="pre">Prog.exe</span></code> if you are on Windows).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--odir ⟨dir⟩">
<code class="descname">-odir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--odir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects object files to directory ⟨dir⟩. For example:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `uname -m`
</pre></div>
</div>
<p>The object files, <code class="docutils literal"><span class="pre">Foo.o</span></code>, <code class="docutils literal"><span class="pre">Bar.o</span></code>, and <code class="docutils literal"><span class="pre">Bumble.o</span></code> would be
put into a subdirectory named after the architecture of the
executing machine (<code class="docutils literal"><span class="pre">x86</span></code>, <code class="docutils literal"><span class="pre">mips</span></code>, etc).</p>
<p>Note that the <code class="docutils literal"><span class="pre">-odir</span></code> option does <em>not</em> affect where the interface
files are put; use the <code class="docutils literal"><span class="pre">-hidir</span></code> option for that. In the above
example, they would still be put in <code class="docutils literal"><span class="pre">parse/Foo.hi</span></code>,
<code class="docutils literal"><span class="pre">parse/Bar.hi</span></code>, and <code class="docutils literal"><span class="pre">gurgle/Bumble.hi</span></code>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ohi ⟨file⟩">
<code class="descname">-ohi</code><code class="descclassname"> ⟨file⟩</code><a class="headerlink" href="#ghc-flag--ohi ⟨file⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>The interface output may be directed to another file
<code class="docutils literal"><span class="pre">bar2/Wurble.iface</span></code> with the option <code class="docutils literal"><span class="pre">-ohi</span> <span class="pre">bar2/Wurble.iface</span></code>
(not recommended).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you redirect the interface file somewhere that GHC can’t
find it, then the recompilation checker may get confused (at the
least, you won’t get any recompilation avoidance). We recommend
using a combination of <code class="docutils literal"><span class="pre">-hidir</span></code> and <code class="docutils literal"><span class="pre">-hisuf</span></code> options instead, if
possible.</p>
</div>
<p>To avoid generating an interface at all, you could use this option
to redirect the interface into the bit bucket: <code class="docutils literal"><span class="pre">-ohi</span> <span class="pre">/dev/null</span></code>,
for example.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--hidir ⟨dir⟩">
<code class="descname">-hidir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--hidir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all generated interface files into ⟨dir⟩, instead of the
default.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--stubdir ⟨dir⟩">
<code class="descname">-stubdir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--stubdir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are
generated when the Haskell source contains a <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> or
<code class="docutils literal"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">&quot;&amp;wrapper&quot;</span></code> declaration (see
<a class="reference internal" href="ffi-chap.html#foreign-export-ghc"><span class="std std-ref">Using foreign export and foreign import ccall &quot;wrapper&quot; with GHC</span></a>). The <code class="docutils literal"><span class="pre">-stubdir</span></code> option behaves in
exactly the same way as <code class="docutils literal"><span class="pre">-odir</span></code> and <code class="docutils literal"><span class="pre">-hidir</span></code> with respect to
hierarchical modules.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--dumpdir ⟨dir⟩">
<code class="descname">-dumpdir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--dumpdir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all dump files into ⟨dir⟩. Dump files are generated when
<code class="docutils literal"><span class="pre">-ddump-to-file</span></code> is used with other <code class="docutils literal"><span class="pre">-ddump-*</span></code> flags.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--outputdir ⟨dir⟩">
<code class="descname">-outputdir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--outputdir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">-outputdir</span></code> option is shorthand for the combination of
<a class="reference internal" href="#ghc-flag--odir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code></a>, <a class="reference internal" href="#ghc-flag--hidir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-hidir</span> <span class="pre">⟨dir⟩</span></code></a>, <a class="reference internal" href="#ghc-flag--stubdir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-stubdir</span>
<span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag--dumpdir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dumpdir</span> <span class="pre">⟨dir⟩</span></code></a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--osuf ⟨suffix⟩">
<code class="descname">-osuf</code><code class="descclassname"> ⟨suffix⟩</code><a class="headerlink" href="#ghc-flag--osuf ⟨suffix⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">-osuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal"><span class="pre">.o</span></code> file suffix for object
files to whatever you specify. We use this when compiling libraries,
so that objects for the profiling versions of the libraries don’t
clobber the normal ones.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--hisuf ⟨suffix⟩">
<code class="descname">-hisuf</code><code class="descclassname"> ⟨suffix⟩</code><a class="headerlink" href="#ghc-flag--hisuf ⟨suffix⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarly, the <code class="docutils literal"><span class="pre">-hisuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal"><span class="pre">.hi</span></code> file
suffix for non-system interface files (see <a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p>
<p>The <code class="docutils literal"><span class="pre">-hisuf</span></code>/<code class="docutils literal"><span class="pre">-osuf</span></code> game is particularly useful if you want to
compile a program both with and without profiling, in the same
directory. You can say:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc ...
</pre></div>
</div>
<p>to get the ordinary version, and</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc ... -osuf prof.o -hisuf prof.hi -prof -fprof-auto
</pre></div>
</div>
<p>to get the profiled version.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--hcsuf ⟨suffix⟩">
<code class="descname">-hcsuf</code><code class="descclassname"> ⟨suffix⟩</code><a class="headerlink" href="#ghc-flag--hcsuf ⟨suffix⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Finally, the option <code class="docutils literal"><span class="pre">-hcsuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal"><span class="pre">.hc</span></code> file
suffix for compiler-generated intermediate C files.</p>
</dd></dl>

</div>
<div class="section" id="keeping-intermediate-files">
<span id="keeping-intermediates"></span><h2>7.8.5. Keeping Intermediate Files<a class="headerlink" href="#keeping-intermediate-files" title="Permalink to this headline">¶</a></h2>
<p id="index-7">The following options are useful for keeping (or not keeping) certain
intermediate files around, when normally GHC would throw these away after
compilation:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--keep-hc-file">
<code class="descname">-keep-hc-file</code><a class="headerlink" href="#ghc-flag--keep-hc-file" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--keep-hc-files">
<code class="descname">-keep-hc-files</code><a class="headerlink" href="#ghc-flag--keep-hc-files" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep intermediate <code class="docutils literal"><span class="pre">.hc</span></code> files when doing <code class="docutils literal"><span class="pre">.hs</span></code>-to-<code class="docutils literal"><span class="pre">.o</span></code>
compilations via <a class="reference internal" href="codegens.html#c-code-gen"><span class="std std-ref">C</span></a> (Note: <code class="docutils literal"><span class="pre">.hc</span></code> files are only
generated by <a class="reference internal" href="codegens.html#unreg"><span class="std std-ref">unregisterised</span></a> compilers).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--keep-hi-files">
<code class="descname">-keep-hi-files</code><a class="headerlink" href="#ghc-flag--keep-hi-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-8">Keep intermediate <code class="docutils literal"><span class="pre">.hi</span></code> files. This is the default. You may use
<code class="docutils literal"><span class="pre">-no-keep-hi-files</span></code> if you are not interested in the <code class="docutils literal"><span class="pre">.hi</span></code> files.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--keep-llvm-file">
<code class="descname">-keep-llvm-file</code><a class="headerlink" href="#ghc-flag--keep-llvm-file" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--keep-llvm-files">
<code class="descname">-keep-llvm-files</code><a class="headerlink" href="#ghc-flag--keep-llvm-files" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Implies:</th><td class="field-body"><a class="reference internal" href="phases.html#ghc-flag--fllvm"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fllvm</span></code></a></td>
</tr>
</tbody>
</table>
<p>Keep intermediate <code class="docutils literal"><span class="pre">.ll</span></code> files when doing <code class="docutils literal"><span class="pre">.hs</span></code>-to-<code class="docutils literal"><span class="pre">.o</span></code>
compilations via <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM</span></a> (Note: <code class="docutils literal"><span class="pre">.ll</span></code> files
aren’t generated when using the native code generator, you may need
to use <a class="reference internal" href="phases.html#ghc-flag--fllvm"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fllvm</span></code></a> to force them to be produced).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--keep-o-files">
<code class="descname">-keep-o-files</code><a class="headerlink" href="#ghc-flag--keep-o-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-9">Keep intermediate <code class="docutils literal"><span class="pre">.o</span></code> files. This is the default. You may use
<code class="docutils literal"><span class="pre">-no-keep-o-files</span></code> if you are not interested in the <code class="docutils literal"><span class="pre">.o</span></code> files.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--keep-s-file">
<code class="descname">-keep-s-file</code><a class="headerlink" href="#ghc-flag--keep-s-file" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--keep-s-files">
<code class="descname">-keep-s-files</code><a class="headerlink" href="#ghc-flag--keep-s-files" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep intermediate <code class="docutils literal"><span class="pre">.s</span></code> files.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--keep-tmp-files">
<code class="descname">-keep-tmp-files</code><a class="headerlink" href="#ghc-flag--keep-tmp-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-10">Instructs the GHC driver not to delete any of its temporary files,
which it normally keeps in <code class="docutils literal"><span class="pre">/tmp</span></code> (or possibly elsewhere; see
<a class="reference internal" href="#temp-files"><span class="std std-ref">Redirecting temporary files</span></a>). Running GHC with <code class="docutils literal"><span class="pre">-v</span></code> will show you what
temporary files were generated along the way.</p>
</dd></dl>

</div>
<div class="section" id="redirecting-temporary-files">
<span id="temp-files"></span><h2>7.8.6. Redirecting temporary files<a class="headerlink" href="#redirecting-temporary-files" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-11"></span><dl class="ghc-flag">
<dt id="ghc-flag--tmpdir ⟨dir⟩">
<code class="descname">-tmpdir</code><code class="descclassname"> ⟨dir⟩</code><a class="headerlink" href="#ghc-flag--tmpdir ⟨dir⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>If you have trouble because of running out of space in <code class="docutils literal"><span class="pre">/tmp</span></code> (or
wherever your installation thinks temporary files should go), you
may use the <a class="reference internal" href="#ghc-flag--tmpdir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-tmpdir</span> <span class="pre">⟨dir⟩</span></code></a> option option to specify an
alternate directory. For example, <code class="docutils literal"><span class="pre">-tmpdir</span> <span class="pre">.</span></code> says to put temporary files
in the current working directory.</p>
<p id="index-12">Alternatively, use your <span class="target" id="index-13"></span><code class="xref std std-envvar docutils literal"><span class="pre">TMPDIR</span></code> environment variable. Set it to the
name of the directory where temporary files should be put. GCC and other
programs will honour the <span class="target" id="index-14"></span><code class="xref std std-envvar docutils literal"><span class="pre">TMPDIR</span></code> variable as well.</p>
</dd></dl>

</div>
<div class="section" id="other-options-related-to-interface-files">
<span id="hi-options"></span><h2>7.8.7. Other options related to interface files<a class="headerlink" href="#other-options-related-to-interface-files" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-15"></span><dl class="ghc-flag">
<dt id="ghc-flag--ddump-hi">
<code class="descname">-ddump-hi</code><a class="headerlink" href="#ghc-flag--ddump-hi" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps the new interface to standard output.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ddump-hi-diffs">
<code class="descname">-ddump-hi-diffs</code><a class="headerlink" href="#ghc-flag--ddump-hi-diffs" title="Permalink to this definition">¶</a></dt>
<dd><p>The compiler does not overwrite an existing <code class="docutils literal"><span class="pre">.hi</span></code> interface file
if the new one is the same as the old one; this is friendly to
<strong class="command">make</strong>. When an interface does change, it is often enlightening to
be informed. The <a class="reference internal" href="#ghc-flag--ddump-hi-diffs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ddump-hi-diffs</span></code></a> option will make GHC report the
differences between the old and new <code class="docutils literal"><span class="pre">.hi</span></code> files.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ddump-minimal-imports">
<code class="descname">-ddump-minimal-imports</code><a class="headerlink" href="#ghc-flag--ddump-minimal-imports" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump to the file <code class="file docutils literal"><em><span class="pre">M</span></em><span class="pre">.imports</span></code> (where ⟨M⟩ is the name of the module
being compiled) a “minimal” set of import declarations. The
directory where the <code class="docutils literal"><span class="pre">.imports</span></code> files are created can be controlled
via the <a class="reference internal" href="#ghc-flag--dumpdir ⟨dir⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dumpdir</span> <span class="pre">⟨dir⟩</span></code></a> option.</p>
<p>You can safely replace all the import declarations in <code class="file docutils literal"><em><span class="pre">M</span></em><span class="pre">.hs</span></code> with
those found in its respective <code class="docutils literal"><span class="pre">.imports</span></code> file. Why would you want
to do that? Because the “minimal” imports (a) import everything
explicitly, by name, and (b) import nothing that is not required. It
can be quite painful to maintain this property by hand, so this flag
is intended to reduce the labour.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag---show-iface ⟨file⟩">
<code class="descname">--show-iface</code><code class="descclassname"> ⟨file⟩</code><a class="headerlink" href="#ghc-flag---show-iface ⟨file⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>where ⟨file⟩ is the name of an interface file, dumps the contents of
that interface in a human-readable format. See <a class="reference internal" href="using.html#modes"><span class="std std-ref">Modes of operation</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="the-recompilation-checker">
<span id="recomp"></span><h2>7.8.8. The recompilation checker<a class="headerlink" href="#the-recompilation-checker" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-16"></span><dl class="ghc-flag">
<dt id="ghc-flag--fforce-recomp">
<code class="descname">-fforce-recomp</code><a class="headerlink" href="#ghc-flag--fforce-recomp" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off recompilation checking (which is on by default).
Recompilation checking normally stops compilation early, leaving an
existing <code class="docutils literal"><span class="pre">.o</span></code> file in place, if it can be determined that the
module does not need to be recompiled.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-optim-changes">
<code class="descname">-fignore-optim-changes</code><a class="headerlink" href="#ghc-flag--fignore-optim-changes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-hpc-changes">
<code class="descname">-fignore-hpc-changes</code><a class="headerlink" href="#ghc-flag--fignore-hpc-changes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>In the olden days, GHC compared the newly-generated <code class="docutils literal"><span class="pre">.hi</span></code> file with
the previous version; if they were identical, it left the old one alone
and didn’t change its modification date. In consequence, importers of a
module with an unchanged output <code class="docutils literal"><span class="pre">.hi</span></code> file were not recompiled.</p>
<p>This doesn’t work any more. Suppose module <code class="docutils literal"><span class="pre">C</span></code> imports module <code class="docutils literal"><span class="pre">B</span></code>,
and <code class="docutils literal"><span class="pre">B</span></code> imports module <code class="docutils literal"><span class="pre">A</span></code>. So changes to module <code class="docutils literal"><span class="pre">A</span></code> might require
module <code class="docutils literal"><span class="pre">C</span></code> to be recompiled, and hence when <code class="docutils literal"><span class="pre">A.hi</span></code> changes we should
check whether <code class="docutils literal"><span class="pre">C</span></code> should be recompiled. However, the dependencies of
<code class="docutils literal"><span class="pre">C</span></code> will only list <code class="docutils literal"><span class="pre">B.hi</span></code>, not <code class="docutils literal"><span class="pre">A.hi</span></code>, and some changes to <code class="docutils literal"><span class="pre">A</span></code>
(changing the definition of a function that appears in an inlining of a
function exported by <code class="docutils literal"><span class="pre">B</span></code>, say) may conceivably not change <code class="docutils literal"><span class="pre">B.hi</span></code> one
jot. So now…</p>
<p>GHC calculates a fingerprint (in fact an MD5 hash) of each interface
file, and of each declaration within the interface file. It also keeps
in every interface file a list of the fingerprints of everything it used
when it last compiled the file. If the source file’s modification date
is earlier than the <code class="docutils literal"><span class="pre">.o</span></code> file’s date (i.e. the source hasn’t changed
since the file was last compiled), and the recompilation checking is on,
GHC will be clever. It compares the fingerprints on the things it needs
this time with the fingerprints on the things it needed last time
(gleaned from the interface file of the module being compiled); if they
are all the same it stops compiling early in the process saying
“Compilation IS NOT required”. What a beautiful sight!</p>
<p>You can read about <a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance">how all this
works</a>
in the GHC commentary.</p>
</div>
<div class="section" id="how-to-compile-mutually-recursive-modules">
<span id="mutual-recursion"></span><h2>7.8.9. How to compile mutually recursive modules<a class="headerlink" href="#how-to-compile-mutually-recursive-modules" title="Permalink to this headline">¶</a></h2>
<p id="index-17">GHC supports the compilation of mutually recursive modules. This section
explains how.</p>
<p>Every cycle in the module import graph must be broken by a <code class="docutils literal"><span class="pre">hs-boot</span></code>
file. Suppose that modules <code class="docutils literal"><span class="pre">A.hs</span></code> and <code class="docutils literal"><span class="pre">B.hs</span></code> are Haskell source
files, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span>module A where
    import B( TB(..) )

    newtype TA = MkTA Int

    f :: TB -&gt; TA
    f (MkTB x) = MkTA x

module B where
    import {-# SOURCE #-} A( TA(..) )

    data TB = MkTB !Int

    g :: TA -&gt; TB
    g (MkTA x) = MkTB x
</pre></div>
</div>
<p id="index-18">Here <code class="docutils literal"><span class="pre">A</span></code> imports <code class="docutils literal"><span class="pre">B</span></code>, but <code class="docutils literal"><span class="pre">B</span></code> imports <code class="docutils literal"><span class="pre">A</span></code> with a
<code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> pragma, which breaks the circular dependency. Every
loop in the module import graph must be broken by a <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>
import; or, equivalently, the module import graph must be acyclic if
<code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> imports are ignored.</p>
<p>For every module <code class="docutils literal"><span class="pre">A.hs</span></code> that is <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>-imported in this
way there must exist a source file <code class="docutils literal"><span class="pre">A.hs-boot</span></code>. This file contains an
abbreviated version of <code class="docutils literal"><span class="pre">A.hs</span></code>, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>
    <span class="kr">newtype</span> <span class="kt">TA</span> <span class="ow">=</span> <span class="kt">MkTA</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>To compile these three files, issue the following commands:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc -c A.hs-boot    -- Produces A.hi-boot, A.o-boot
ghc -c B.hs         -- Consumes A.hi-boot, produces B.hi, B.o
ghc -c A.hs         -- Consumes B.hi, produces A.hi, A.o
ghc -o foo A.o B.o  -- Linking the program
</pre></div>
</div>
<p>There are several points to note here:</p>
<ul>
<li><p class="first">The file <code class="docutils literal"><span class="pre">A.hs-boot</span></code> is a programmer-written source file. It must
live in the same directory as its parent source file <code class="docutils literal"><span class="pre">A.hs</span></code>.
Currently, if you use a literate source file <code class="docutils literal"><span class="pre">A.lhs</span></code> you must also
use a literate boot file, <code class="docutils literal"><span class="pre">A.lhs-boot</span></code>; and vice versa.</p>
</li>
<li><p class="first">A <code class="docutils literal"><span class="pre">hs-boot</span></code> file is compiled by GHC, just like a <code class="docutils literal"><span class="pre">hs</span></code> file:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ghc -c A.hs-boot
</pre></div>
</div>
<p>When a hs-boot file <code class="docutils literal"><span class="pre">A.hs-boot</span></code> is compiled, it is checked for
scope and type errors. When its parent module <code class="docutils literal"><span class="pre">A.hs</span></code> is compiled,
the two are compared, and an error is reported if the two are
inconsistent.</p>
</li>
<li><p class="first">Just as compiling <code class="docutils literal"><span class="pre">A.hs</span></code> produces an interface file <code class="docutils literal"><span class="pre">A.hi</span></code>, and
an object file <code class="docutils literal"><span class="pre">A.o</span></code>, so compiling <code class="docutils literal"><span class="pre">A.hs-boot</span></code> produces an
interface file <code class="docutils literal"><span class="pre">A.hi-boot</span></code>, and a pseudo-object file <code class="docutils literal"><span class="pre">A.o-boot</span></code>:</p>
<ul class="simple">
<li>The pseudo-object file <code class="docutils literal"><span class="pre">A.o-boot</span></code> is empty (don’t link it!), but
it is very useful when using a Makefile, to record when the
<code class="docutils literal"><span class="pre">A.hi-boot</span></code> was last brought up to date (see <a class="reference internal" href="#using-make"><span class="std std-ref">Using make</span></a>).</li>
<li>The <code class="docutils literal"><span class="pre">hi-boot</span></code> generated by compiling a <code class="docutils literal"><span class="pre">hs-boot</span></code> file is in
the same machine-generated binary format as any other
GHC-generated interface file (e.g. <code class="docutils literal"><span class="pre">B.hi</span></code>). You can display its
contents with <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--show-iface</span></code>. If you specify a directory for
interface files, the <code class="docutils literal"><span class="pre">-ohidir</span></code> flag, then that affects <code class="docutils literal"><span class="pre">hi-boot</span></code> files
too.</li>
</ul>
</li>
<li><p class="first">If hs-boot files are considered distinct from their parent source
files, and if a <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> import is considered to refer to
the hs-boot file, then the module import graph must have no cycles.
The command <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code> will report an error if a cycle is found.</p>
</li>
<li><p class="first">A module <code class="docutils literal"><span class="pre">M</span></code> that is <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>-imported in a program will
usually also be ordinarily imported elsewhere. If not, <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span></code>
automatically adds <code class="docutils literal"><span class="pre">M</span></code> to the set of modules it tries to compile
and link, to ensure that <code class="docutils literal"><span class="pre">M</span></code>’s implementation is included in the
final program.</p>
</li>
</ul>
<p>A hs-boot file need only contain the bare minimum of information needed
to get the bootstrapping process started. For example, it doesn’t need
to contain declarations for <em>everything</em> that module <code class="docutils literal"><span class="pre">A</span></code> exports, only
the things required by the module(s) that import <code class="docutils literal"><span class="pre">A</span></code> recursively.</p>
<p>A hs-boot file is written in a subset of Haskell:</p>
<ul>
<li><p class="first">The module header (including the export list), and import statements,
are exactly as in Haskell, and so are the scoping rules. Hence, to
mention a non-Prelude type or class, you must import it.</p>
</li>
<li><p class="first">There must be no value declarations, but there can be type signatures
for values. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">double</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
</li>
<li><p class="first">Fixity declarations are exactly as in Haskell.</p>
</li>
<li><p class="first">Vanilla type synonym declarations are exactly as in Haskell.</p>
</li>
<li><p class="first">Open type and data family declarations are exactly as in Haskell.</p>
</li>
<li><p class="first">A closed type family may optionally omit its equations, as in the
following example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kr">family</span> <span class="kt">ClosedFam</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">..</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">..</span></code> is meant literally – you should write two dots in your
file. Note that the <code class="docutils literal"><span class="pre">where</span></code> clause is still necessary to
distinguish closed families from open ones. If you give any equations
of a closed family, you must give all of them, in the same order as
they appear in the accompanying Haskell file.</p>
</li>
<li><p class="first">A data type declaration can either be given in full, exactly as in
Haskell, or it can be given abstractly, by omitting the ‘=’ sign and
everything that follows. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>
</div>
<p>In a <em>source</em> program this would declare TA to have no constructors
(a GHC extension: see <a class="reference internal" href="glasgow_exts.html#nullary-types"><span class="std std-ref">Data types with no constructors</span></a>), but in an hi-boot file
it means “I don’t know or care what the constructors are”. This is
the most common form of data type declaration, because it’s easy to
get right. You <em>can</em> also write out the constructors but, if you do
so, you must write it out precisely as in its real definition.</p>
<p>If you do not write out the constructors, you may need to give a kind
annotation (<a class="reference internal" href="glasgow_exts.html#kinding"><span class="std std-ref">Explicitly-kinded quantification</span></a>), to tell GHC the kind of the type
variable, if it is not “*”. (In source files, this is worked out
from the way the type variable is used in the constructors.) For
example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">R</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="n">y</span>
</pre></div>
</div>
<p>You cannot use <code class="docutils literal"><span class="pre">deriving</span></code> on a data type declaration; write an
<code class="docutils literal"><span class="pre">instance</span></code> declaration instead.</p>
</li>
<li><p class="first">Class declarations is exactly as in Haskell, except that you may not
put default method declarations. You can also omit all the
superclasses and class methods entirely; but you must either omit
them all or put them all in.</p>
</li>
<li><p class="first">You can include instance declarations just as in Haskell; but omit
the “where” part.</p>
</li>
<li><p class="first">The default role for abstract datatype parameters is now
representational. (An abstract datatype is one with no constructors
listed.) To get another role, use a role annotation. (See
<a class="reference internal" href="glasgow_exts.html#roles"><span class="std std-ref">Roles</span></a>.)</p>
</li>
</ul>
</div>
<div class="section" id="module-signatures">
<span id="id2"></span><h2>7.8.10. Module signatures<a class="headerlink" href="#module-signatures" title="Permalink to this headline">¶</a></h2>
<p id="index-19">GHC 8.2 supports module signatures (<code class="docutils literal"><span class="pre">hsig</span></code> files), which allow you to
write a signature in place of a module implementation, deferring the
choice of implementation until a later point in time.  This feature is
not intended to be used without <a class="reference external" href="http://www.haskell.org/cabal/">Cabal</a>; this manual entry will focus
on the syntax and semantics of signatures.</p>
<p>To start with an example, suppose you had a module <code class="docutils literal"><span class="pre">A</span></code> which made use of some
string operations.  Using normal module imports, you would only
be able to pick a particular implementation of strings:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Str</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kt">Str</span> <span class="ow">=</span> <span class="kt">String</span>

    <span class="n">empty</span> <span class="ow">::</span> <span class="kt">Str</span>
    <span class="n">empty</span> <span class="ow">=</span> <span class="s">&quot;&quot;</span>

    <span class="n">toString</span> <span class="ow">::</span> <span class="kt">Str</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
    <span class="n">toString</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">s</span>

<span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>
    <span class="kr">import</span> <span class="nn">Text</span>
    <span class="n">z</span> <span class="ow">=</span> <span class="n">toString</span> <span class="n">empty</span>
</pre></div>
</div>
<p>By replacing <code class="docutils literal"><span class="pre">Str.hs</span></code> with a signature <code class="docutils literal"><span class="pre">Str.hsig</span></code>, <code class="docutils literal"><span class="pre">A</span></code> (and
any other modules in this package) are now parametrized by
a string implementation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">Str</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">Str</span>
    <span class="n">empty</span> <span class="ow">::</span> <span class="kt">Str</span>
    <span class="n">toString</span> <span class="ow">::</span> <span class="kt">Str</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>We can typecheck <code class="docutils literal"><span class="pre">A</span></code> against this signature, or we can instantiate
<code class="docutils literal"><span class="pre">Str</span></code> with a module that provides the following declarations.  Refer
to Cabal’s documentation for a more in-depth discussion on how to
instantiate signatures.</p>
<p>Module signatures actually consist of two closely related features:</p>
<ul class="simple">
<li>The ability to define an <code class="docutils literal"><span class="pre">hsig</span></code> file, containing type definitions
and type signature for values which can be used by modules that
import the signature, and must be provided by the eventual
implementing module, and</li>
<li>The ability to <em>inherit</em> required signatures from packages we
depend upon, combining the signatures into a single merged
signature which reflects the requirements of any locally defined
signature, as well as the requirements of our dependencies.</li>
</ul>
<p>A signature file is denoted by an <code class="docutils literal"><span class="pre">hsig</span></code> file; every required
signature must have an <code class="docutils literal"><span class="pre">hsig</span></code> file (even if it is an empty one),
including required signatures inherited from dependencies.  Signatures
can be imported using an ordinary <code class="docutils literal"><span class="pre">import</span> <span class="pre">Sig</span></code> declaration.</p>
<p><code class="docutils literal"><span class="pre">hsig</span></code> files are written in a variant of Haskell similar
to <code class="docutils literal"><span class="pre">hs-boot</span></code> files, but with some slight changes:</p>
<ul>
<li><p class="first">The header of a signature is <code class="docutils literal"><span class="pre">signature</span> <span class="pre">A</span> <span class="pre">where</span> <span class="pre">...</span></code> (instead
of the usual <code class="docutils literal"><span class="pre">module</span> <span class="pre">A</span> <span class="pre">where</span> <span class="pre">...</span></code>).</p>
</li>
<li><p class="first">Import statements and scoping rules are exactly as in Haskell.
To mention a non-Prelude type or class, you must import it.</p>
</li>
<li><p class="first">Unlike regular modules, the defined entities of
a signature include not only those written in the local
<code class="docutils literal"><span class="pre">hsig</span></code> file, but also those from inherited signatures
(as inferred from the <a class="reference internal" href="packages.html#ghc-flag--package-id ⟨unit-id⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-package-id</span> <span class="pre">⟨unit-id⟩</span></code></a> flags).
These entities are not considered in scope when typechecking
the local <code class="docutils literal"><span class="pre">hsig</span></code> file, but are available for import by
any module or signature which imports the signature.  The
one exception to this rule is the export list, described
below.</p>
<p>If a declaration occurs in multiple inherited signatures,
they will be <em>merged</em> together.  For values, we require
that the types from both signatures match exactly; however,
other declarations may merge in more interesting ways.
The merging operation in these cases has the effect of
textually replacing all occurrences of the old name with
a reference to the new, merged declaration.  For example,
if we have the following two signatures:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">T</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>

<span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span>
    <span class="n">g</span> <span class="ow">::</span> <span class="kt">T</span>
</pre></div>
</div>
<p>the resulting merged signature would be:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">MkT</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>
    <span class="n">g</span> <span class="ow">::</span> <span class="kt">T</span>
</pre></div>
</div>
</li>
<li><p class="first">If no export list is provided for a signature, the exports of
a signature are all of its defined entities merged with the
exports of all inherited signatures.</p>
<p>If you want to reexport an entity from a signature, you must
also include a <code class="docutils literal"><span class="pre">module</span> <span class="pre">SigName</span></code> export, so that all of the
entities defined in the signature are exported.  For example,
the following module exports both <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">Int</span></code> from
<code class="docutils literal"><span class="pre">Prelude</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span><span class="p">(</span><span class="kr">module</span> <span class="nn">A</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Reexports merge with local declarations; thus, the signature above
would successfully merge with:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>The only permissible implementation of such a signature is a module
which reexports precisely the same entity:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">A</span> <span class="p">(</span><span class="nf">f</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="n">f</span> <span class="ow">=</span> <span class="mi">2</span> <span class="ow">::</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Conversely, any entity requested by a signature can be provided
by a reexport from the implementing module.  This is different from
<code class="docutils literal"><span class="pre">hs-boot</span></code> files, which require every entity to be defined
locally in the implementing module.</p>
</li>
<li><p class="first">GHC has experimental support for <em>signature thinning</em>, which is used
when a signature has an explicit export list without a module export of the
signature itself.  In this case, the export list applies to the final export
list <em>after</em> merging, in particular, you may refer to entities which are not
declared in the body of the local <code class="docutils literal"><span class="pre">hsig</span></code> file.</p>
<p>The semantics in this case is that the set of required entities is defined
exclusively by its exports; if an entity is not mentioned in the export list,
it is not required.  The motivation behind this feature is to allow a library
author to provide an omnibus signature containing the type of every function
someone might want to use, while a client thins down the exports to the ones
they actually require.  For example, supposing that you have inherited a
signature for strings, you might write a local signature of this form, listing
only the entities that you need:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">Str</span> <span class="p">(</span><span class="kt">Str</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">concat</span><span class="p">)</span> <span class="kr">where</span>
    <span class="c1">-- empty</span>
</pre></div>
</div>
<p>A few caveats apply here.  First, it is illegal to export an entity
which refers to a locally defined type which itself is not exported
(GHC will report an error in this case).  Second, signatures which
come from dependencies which expose modules cannot be thinned in this
way (after all, the dependency itself may need the entity); these
requirements are unconditionally exported.  Finally, any module
reexports must refer to modules imported by the local signature
(even if an inherited signature exported the module).</p>
<p>We may change the syntax and semantics of this feature in the future.</p>
</li>
<li><p class="first">The declarations and types from signatures of dependencies
that will be merged in are not in scope when type checking
an <code class="docutils literal"><span class="pre">hsig</span></code> file.  To refer to any such type, you must
declare it yourself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="c1">-- OK, assuming we inherited an A that defines T</span>
<span class="nf">signature</span> <span class="kt">A</span> <span class="p">(</span><span class="kt">T</span><span class="p">)</span> <span class="kr">where</span>
    <span class="c1">-- empty</span>

<span class="c1">-- Not OK</span>
<span class="nf">signature</span> <span class="kt">A</span> <span class="p">(</span><span class="kt">T</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>

<span class="c1">-- OK</span>
<span class="nf">signature</span> <span class="kt">A</span> <span class="p">(</span><span class="kt">T</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">T</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">T</span> <span class="ow">-&gt;</span> <span class="kt">T</span>
</pre></div>
</div>
</li>
<li><p class="first">There must be no value declarations, but there can be type signatures
for values.  For example, we might define the signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="n">double</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>A module implementing <code class="docutils literal"><span class="pre">A</span></code> would have to export the function
<code class="docutils literal"><span class="pre">double</span></code> with a type definitionally equal to the signature.
Note that this means you can’t implement <code class="docutils literal"><span class="pre">double</span></code> using
a polymorphic function <code class="docutils literal"><span class="pre">double</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<p>Note that signature matching does check if <em>fixity</em> matches, so be
sure specify fixity of ordinary identifiers if you intend to use them
with backticks.</p>
</li>
<li><p class="first">Fixity, type synonym, open type/data family declarations
are permitted as in normal Haskell.</p>
</li>
<li><p class="first">Closed type family declarations are permitted as in normal
Haskell.  They can also be given abstractly, as in the
following example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kr">family</span> <span class="kt">ClosedFam</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">..</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">..</span></code> is meant literally – you should write two dots in
your file.  The <code class="docutils literal"><span class="pre">where</span></code> clause distinguishes closed families
from open ones.</p>
</li>
<li><p class="first">A data type declaration can either be given in full, exactly
as in Haskell, or it can be given abstractly, by omitting the ‘=’
sign and everything that follows.  For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>
</div>
<p>Abstract data types can be implemented not only with data
declarations, but also newtypes and type synonyms (with the
restriction that a type synonym must be fully eta-reduced,
e.g., <code class="docutils literal"><span class="pre">type</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">...</span></code> to be accepted.)  For example,
the following are all valid implementations of the T above:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="c1">-- Algebraic data type</span>
<span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="n">a</span> <span class="n">b</span>

<span class="c1">-- Newtype</span>
<span class="kr">newtype</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1">-- Type synonym</span>
<span class="kr">data</span> <span class="kt">T2</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MkT2</span> <span class="n">a</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b</span>
<span class="kr">type</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T2</span>
</pre></div>
</div>
<p>Data type declarations merge only with other data type
declarations which match exactly, except abstract data,
which can merge with <code class="docutils literal"><span class="pre">data</span></code>, <code class="docutils literal"><span class="pre">newtype</span></code> or <code class="docutils literal"><span class="pre">type</span></code>
declarations.  Merges with type synonyms are especially useful:
suppose you are using a package of strings which has left the type of
characters in the string unspecified:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">Str</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">Str</span>
    <span class="kr">data</span> <span class="kt">Elem</span>
    <span class="n">head</span> <span class="ow">::</span> <span class="kt">Str</span> <span class="ow">-&gt;</span> <span class="kt">Elem</span>
</pre></div>
</div>
<p>If you locally define a signature which specifies
<code class="docutils literal"><span class="pre">type</span> <span class="pre">Elem</span> <span class="pre">=</span> <span class="pre">Char</span></code>, you can now use <code class="docutils literal"><span class="pre">head</span></code> from the
inherited signature as if it returned a <code class="docutils literal"><span class="pre">Char</span></code>.</p>
<p>If you do not write out the constructors, you may need to give a kind to tell
GHC what the kinds of the type variables are, if they are not the default
<code class="docutils literal"><span class="pre">*</span></code>.  Unlike regular data type declarations, the return kind of an
abstract data declaration can be anything (in which case it probably
will be implemented using a type synonym.)  This can be used
to allow compile-time representation polymorphism (as opposed to
<a class="reference external" href="#runtime-rep">run-time representation polymorphism</a>),
as in this example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">Number</span> <span class="kr">where</span>
    <span class="kr">import</span> <span class="nn">GHC.Types</span>
    <span class="kr">data</span> <span class="kt">Rep</span> <span class="ow">::</span> <span class="kt">RuntimeRep</span>
    <span class="kr">data</span> <span class="kt">Number</span> <span class="ow">::</span> <span class="kt">TYPE</span> <span class="kt">Rep</span>
    <span class="n">plus</span> <span class="ow">::</span> <span class="kt">Number</span> <span class="ow">-&gt;</span> <span class="kt">Number</span> <span class="ow">-&gt;</span> <span class="kt">Number</span>
</pre></div>
</div>
<p>Roles of type parameters are subject to the subtyping
relation <code class="docutils literal"><span class="pre">phantom</span> <span class="pre">&lt;</span> <span class="pre">representational</span> <span class="pre">&lt;</span> <span class="pre">nominal</span></code>: for example,
an abstract type with a nominal type parameter can be implemented
using a concrete type with a representational type parameter.
Merging respects this subtyping relation (e.g., <code class="docutils literal"><span class="pre">nominal</span></code>
merged with <code class="docutils literal"><span class="pre">representational</span></code> is <code class="docutils literal"><span class="pre">representational</span></code>.)
Roles in signatures default to <code class="docutils literal"><span class="pre">nominal</span></code>, which gives maximum
flexibility on the implementor’s side.  You should only need to
give an explicit role annotation if a client of the signature
would like to coerce the abstract type in a type parameter (in which case you
should specify <code class="docutils literal"><span class="pre">representational</span></code> explicitly.)  Unlike
regular data types, we do <em>not</em> assume that abstract
data types are representationally injective: if we have
<code class="docutils literal"><span class="pre">Coercible</span> <span class="pre">(T</span> <span class="pre">a)</span> <span class="pre">(T</span> <span class="pre">b)</span></code>, and <code class="docutils literal"><span class="pre">T</span></code> has role <code class="docutils literal"><span class="pre">nominal</span></code>,
this does not imply that <code class="docutils literal"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">b</span></code>.</p>
</li>
<li><p class="first">A class declarations can either be abstract or concrete.  An
abstract class is one with no superclasses or class methods:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">class</span> <span class="kt">Key</span> <span class="n">k</span>
</pre></div>
</div>
<p>It can be implemented in any way, with any set of superclasses
and methods; however, modules depending on an abstract class
are not permitted to define instances (as of GHC 8.2, this
restriction is not checked, see <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/13086">Trac #13086</a>.)
These declarations can be implemented by type synonyms
of kind <code class="docutils literal"><span class="pre">Constraint</span></code>; this can be useful if you want to parametrize
over a constraint in functions.  For example, with the
<code class="docutils literal"><span class="pre">ConstraintKinds</span></code> extension, this type synonym is a valid
implementation of the signature above:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kt">Key</span> <span class="ow">=</span> <span class="kt">Eq</span>
</pre></div>
</div>
<p>A concrete class specifies its superclasses, methods,
default method signatures (but not their implementations)
and a <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragma.  Unlike regular Haskell classes,
you don’t have to explicitly declare a default for a method
to make it optional vis-a-vis the <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragma.</p>
<p>When merging class declarations, we require that the superclasses
and methods match exactly; however, <code class="docutils literal"><span class="pre">MINIMAL</span></code> pragmas are logically
ORed together, and a method with a default signature will merge
successfully against one that does not.</p>
</li>
<li><p class="first">You can include instance declarations as in Haskell; just omit the
“where” part.  An instance declaration need not be implemented directly;
if an instance can be derived based on instances in the environment,
it is considered implemented.  For example, the following signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">signature</span> <span class="kt">A</span> <span class="kr">where</span>
    <span class="kr">data</span> <span class="kt">Str</span>
    <span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Str</span>
</pre></div>
</div>
<p>is considered implemented by the following module, since there
are instances of <code class="docutils literal"><span class="pre">Eq</span></code> for <code class="docutils literal"><span class="pre">[]</span></code> and <code class="docutils literal"><span class="pre">Char</span></code> which can be combined
to form an instance <code class="docutils literal"><span class="pre">Eq</span> <span class="pre">[Char]</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kt">Str</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>Unlike other declarations, for which only the entities declared
in a signature file are brought into scope, instances from the
implementation are always brought into scope, even if they were
not declared in the signature file.  This means that a module may
typecheck against a signature, but not against a matching
implementation.  You can avoid situations like this by never
defining orphan instances inside a package that has signatures.</p>
<p>Instance declarations are only merged if their heads are exactly
the same, so it is possible to get into a situation where GHC
thinks that instances in a signature are overlapping, even if
they are implemented in a non-overlapping way.  If this is
giving you problems give us a shout.</p>
</li>
<li><p class="first">Any orphan instances which are brought into scope by an import
from a signature are unconditionally considered in scope, even
if the eventual implementing module doesn’t actually import the
same orphans.</p>
</li>
</ul>
<p>Known limitations:</p>
<ul class="simple">
<li>Pattern synonyms are not supported.</li>
<li>Algebraic data types specified in a signature cannot be implemented using
pattern synonyms.  See <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/12717">Trac #12717</a></li>
</ul>
</div>
<div class="section" id="using-make">
<span id="id3"></span><h2>7.8.11. Using <code class="docutils literal"><span class="pre">make</span></code><a class="headerlink" href="#using-make" title="Permalink to this headline">¶</a></h2>
<p id="index-20">It is reasonably straightforward to set up a <code class="docutils literal"><span class="pre">Makefile</span></code> to use with
GHC, assuming you name your source files the same as your modules. Thus:</p>
<div class="highlight-makefile"><div class="highlight"><pre><span></span><span class="nv">HC</span>      <span class="o">=</span> ghc
<span class="nv">HC_OPTS</span> <span class="o">=</span> -cpp <span class="k">$(</span>EXTRA_HC_OPTS<span class="k">)</span>

<span class="nv">SRCS</span> <span class="o">=</span> Main.lhs Foo.lhs Bar.lhs
<span class="nv">OBJS</span> <span class="o">=</span> Main.o   Foo.o   Bar.o

<span class="nf">.SUFFIXES </span><span class="o">:</span> .<span class="n">o</span> .<span class="n">hs</span> .<span class="n">hi</span> .<span class="n">lhs</span> .<span class="n">hc</span> .<span class="n">s</span>

<span class="nf">cool_pgm </span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
        rm -f <span class="nv">$@</span>
        <span class="k">$(</span>HC<span class="k">)</span> -o <span class="nv">$@</span> <span class="k">$(</span>HC_OPTS<span class="k">)</span> <span class="k">$(</span>OBJS<span class="k">)</span>

<span class="c"># Standard suffix rules</span>
<span class="nf">.o.hi</span><span class="o">:</span>
        @:

<span class="nf">.lhs.o</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.hs.o</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.o-boot.hi-boot</span><span class="o">:</span>
        @:

<span class="nf">.lhs-boot.o-boot</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.hs-boot.o-boot</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="c"># Inter-module dependencies</span>
<span class="nf">Foo.o Foo.hc Foo.s    </span><span class="o">:</span> <span class="n">Baz</span>.<span class="n">hi</span>          <span class="c"># Foo imports Baz</span>
<span class="nf">Main.o Main.hc Main.s </span><span class="o">:</span> <span class="n">Foo</span>.<span class="n">hi</span> <span class="n">Baz</span>.<span class="n">hi</span>   <span class="c"># Main imports Foo and Baz</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Sophisticated <strong class="command">make</strong> variants may achieve some of the above more
elegantly. Notably, <strong class="command">gmake</strong>’s pattern rules let you write the more
comprehensible:</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">lhs</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>
</pre></div>
</div>
<p class="last">What we’ve shown should work with any <code class="docutils literal"><span class="pre">make</span></code>.</p>
</div>
<p>Note the cheesy <code class="docutils literal"><span class="pre">.o.hi</span></code> rule: It records the dependency of the
interface (<code class="docutils literal"><span class="pre">.hi</span></code>) file on the source. The rule says a <code class="docutils literal"><span class="pre">.hi</span></code> file can
be made from a <code class="docutils literal"><span class="pre">.o</span></code> file by doing…nothing. Which is true.</p>
<p>Note that the suffix rules are all repeated twice, once for normal
Haskell source files, and once for <code class="docutils literal"><span class="pre">hs-boot</span></code> files (see
<a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>).</p>
<p>Note also the inter-module dependencies at the end of the Makefile,
which take the form</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">Foo.o Foo.hc Foo.s    </span><span class="o">:</span> <span class="n">Baz</span>.<span class="n">hi</span>          <span class="c"># Foo imports Baz</span>
</pre></div>
</div>
<p>They tell <code class="docutils literal"><span class="pre">make</span></code> that if any of <code class="docutils literal"><span class="pre">Foo.o</span></code>, <code class="docutils literal"><span class="pre">Foo.hc</span></code> or <code class="docutils literal"><span class="pre">Foo.s</span></code>
have an earlier modification date than <code class="docutils literal"><span class="pre">Baz.hi</span></code>, then the out-of-date
file must be brought up to date. To bring it up to date, <code class="docutils literal"><span class="pre">make</span></code> looks
for a rule to do so; one of the preceding suffix rules does the job
nicely. These dependencies can be generated automatically by <code class="docutils literal"><span class="pre">ghc</span></code>;
see <a class="reference internal" href="#makefile-dependencies"><span class="std std-ref">Dependency generation</span></a></p>
</div>
<div class="section" id="dependency-generation">
<span id="makefile-dependencies"></span><h2>7.8.12. Dependency generation<a class="headerlink" href="#dependency-generation" title="Permalink to this headline">¶</a></h2>
<p id="index-21">Putting inter-dependencies of the form <code class="docutils literal"><span class="pre">Foo.o</span> <span class="pre">:</span> <span class="pre">Bar.hi</span></code> into your
<code class="docutils literal"><span class="pre">Makefile</span></code> by hand is rather error-prone. Don’t worry, GHC has support
for automatically generating the required dependencies. Add the
following to your <code class="docutils literal"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">depend </span><span class="o">:</span>
        ghc -dep-suffix <span class="s1">&#39;&#39;</span> -M <span class="k">$(</span>HC_OPTS<span class="k">)</span> <span class="k">$(</span>SRCS<span class="k">)</span>
</pre></div>
</div>
<p>Now, before you start compiling, and any time you change the <code class="docutils literal"><span class="pre">imports</span></code>
in your program, do <code class="docutils literal"><span class="pre">make</span> <span class="pre">depend</span></code> before you do <code class="docutils literal"><span class="pre">make</span> <span class="pre">cool_pgm</span></code>. The command
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code> will append the needed dependencies to your <code class="docutils literal"><span class="pre">Makefile</span></code>.</p>
<p>In general, <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span> <span class="pre">Foo</span></code> does the following. For each module <code class="docutils literal"><span class="pre">M</span></code> in
the set <code class="docutils literal"><span class="pre">Foo</span></code> plus all its imports (transitively), it adds to the
Makefile:</p>
<ul>
<li><p class="first">A line recording the dependence of the object file on the source
file.</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">M</span>.<span class="n">hs</span>
</pre></div>
</div>
<p>(or <code class="docutils literal"><span class="pre">M.lhs</span></code> if that is the filename you used).</p>
</li>
<li><p class="first">For each import declaration <code class="docutils literal"><span class="pre">import</span> <span class="pre">X</span></code> in <code class="docutils literal"><span class="pre">M</span></code>, a line recording
the dependence of <code class="docutils literal"><span class="pre">M</span></code> on <code class="docutils literal"><span class="pre">X</span></code>:</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">X</span>.<span class="n">hi</span>
</pre></div>
</div>
</li>
<li><p class="first">For each import declaration <code class="docutils literal"><span class="pre">import</span> <span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span> <span class="pre">X</span></code> in <code class="docutils literal"><span class="pre">M</span></code>, a
line recording the dependence of <code class="docutils literal"><span class="pre">M</span></code> on <code class="docutils literal"><span class="pre">X</span></code>:</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">X</span>.<span class="n">hi</span>-<span class="n">boot</span>
</pre></div>
</div>
<p>(See <a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a> for details of <code class="docutils literal"><span class="pre">hi-boot</span></code> style
interface files.)</p>
</li>
</ul>
<p>If <code class="docutils literal"><span class="pre">M</span></code> imports multiple modules, then there will be multiple lines
with <code class="docutils literal"><span class="pre">M.o</span></code> as the target.</p>
<p>There is no need to list all of the source files as arguments to the
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code> command; <code class="docutils literal"><span class="pre">ghc</span></code> traces the dependencies, just like
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span></code> (a new feature in GHC 6.4).</p>
<p>Note that <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code> needs to find a <em>source file</em> for each module in
the dependency graph, so that it can parse the import declarations and
follow dependencies. Any pre-compiled modules without source files must
therefore belong to a package <a class="footnote-reference" href="#id5" id="id4">[1]</a>.</p>
<p>By default, <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code> generates all the dependencies, and then
concatenates them onto the end of <code class="docutils literal"><span class="pre">makefile</span></code> (or <code class="docutils literal"><span class="pre">Makefile</span></code> if
<code class="docutils literal"><span class="pre">makefile</span></code> doesn’t exist) bracketed by the lines
“<code class="docutils literal"><span class="pre">#</span> <span class="pre">DO</span> <span class="pre">NOT</span> <span class="pre">DELETE:</span> <span class="pre">Beginning</span> <span class="pre">of</span> <span class="pre">Haskell</span> <span class="pre">dependencies</span></code>” and
“<code class="docutils literal"><span class="pre">#</span> <span class="pre">DO</span> <span class="pre">NOT</span> <span class="pre">DELETE:</span> <span class="pre">End</span> <span class="pre">of</span> <span class="pre">Haskell</span> <span class="pre">dependencies</span></code>”. If these lines
already exist in the <code class="docutils literal"><span class="pre">makefile</span></code>, then the old dependencies are deleted
first.</p>
<p>Don’t forget to use the same <code class="docutils literal"><span class="pre">-package</span></code> options on the <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-M</span></code>
command line as you would when compiling; this enables the dependency
generator to locate any imported modules that come from packages. The
package modules won’t be included in the dependencies generated, though
(but see the <code class="docutils literal"><span class="pre">-include-pkg-deps</span></code> option below).</p>
<p>The dependency generation phase of GHC can take some additional options,
which you may find useful. The options which affect dependency
generation are:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--ddump-mod-cycles">
<code class="descname">-ddump-mod-cycles</code><a class="headerlink" href="#ghc-flag--ddump-mod-cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a list of the cycles in the module graph. This is useful
when trying to eliminate such cycles.</p>
</dd></dl>

<dl class="ghc-flag">
<dt>
<code class="descname">-v2</code></dt>
<dd><p>Print a full list of the module dependencies to stdout. (This is the
standard verbosity flag, so the list will also be displayed with
<code class="docutils literal"><span class="pre">-v3</span></code> and <code class="docutils literal"><span class="pre">-v4</span></code>; see <a class="reference internal" href="using.html#options-help"><span class="std std-ref">Verbosity options</span></a>.)</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--dep-makefile ⟨file⟩">
<code class="descname">-dep-makefile</code><code class="descclassname"> ⟨file⟩</code><a class="headerlink" href="#ghc-flag--dep-makefile ⟨file⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Use ⟨file⟩ as the makefile, rather than <code class="docutils literal"><span class="pre">makefile</span></code> or
<code class="docutils literal"><span class="pre">Makefile</span></code>. If ⟨file⟩ doesn’t exist, <code class="docutils literal"><span class="pre">mkdependHS</span></code> creates it. We
often use <code class="docutils literal"><span class="pre">-dep-makefile</span> <span class="pre">.depend</span></code> to put the dependencies in
<code class="docutils literal"><span class="pre">.depend</span></code> and then <code class="docutils literal"><span class="pre">include</span></code> the file <code class="docutils literal"><span class="pre">.depend</span></code> into
<code class="docutils literal"><span class="pre">Makefile</span></code>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--dep-suffix ⟨suffix⟩">
<code class="descname">-dep-suffix</code><code class="descclassname"> ⟨suffix⟩</code><a class="headerlink" href="#ghc-flag--dep-suffix ⟨suffix⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Make dependencies that declare that files with suffix
<code class="docutils literal"><span class="pre">.⟨suf⟩⟨osuf⟩</span></code> depend on interface files with suffix
<code class="docutils literal"><span class="pre">.⟨suf⟩hi</span></code>, or (for <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> imports) on <code class="docutils literal"><span class="pre">.hi-boot</span></code>.
Multiple <code class="docutils literal"><span class="pre">-dep-suffix</span></code> flags are permitted. For example,
<code class="docutils literal"><span class="pre">-dep-suffix</span> <span class="pre">a_</span> <span class="pre">-dep-suffix</span> <span class="pre">b_</span></code> will make dependencies for <code class="docutils literal"><span class="pre">.hs</span></code>
on <code class="docutils literal"><span class="pre">.hi</span></code>, <code class="docutils literal"><span class="pre">.a_hs</span></code> on <code class="docutils literal"><span class="pre">.a_hi</span></code>, and <code class="docutils literal"><span class="pre">.b_hs</span></code> on <code class="docutils literal"><span class="pre">.b_hi</span></code>.
Note that you must provide at least one suffix; if you do not want a suffix
then pass <code class="docutils literal"><span class="pre">-dep-suffix</span> <span class="pre">''</span></code>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag---exclude-module=⟨file⟩">
<code class="descname">--exclude-module</code><code class="descclassname">=⟨file⟩</code><a class="headerlink" href="#ghc-flag---exclude-module=⟨file⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Regard <code class="docutils literal"><span class="pre">⟨file⟩</span></code> as “stable”; i.e., exclude it from having
dependencies on it.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--include-pkg-deps">
<code class="descname">-include-pkg-deps</code><a class="headerlink" href="#ghc-flag--include-pkg-deps" title="Permalink to this definition">¶</a></dt>
<dd><p>Regard modules imported from packages as unstable, i.e., generate
dependencies on any imported package modules (including <code class="docutils literal"><span class="pre">Prelude</span></code>,
and all other standard Haskell libraries). Dependencies are not
traced recursively into packages; dependencies are only generated
for home-package modules on external-package modules directly
imported by the home package module. This option is normally only
used by the various system libraries.</p>
</dd></dl>

</div>
<div class="section" id="orphan-modules-and-instance-declarations">
<span id="orphan-modules"></span><h2>7.8.13. Orphan modules and instance declarations<a class="headerlink" href="#orphan-modules-and-instance-declarations" title="Permalink to this headline">¶</a></h2>
<p>Haskell specifies that when compiling module <code class="docutils literal"><span class="pre">M</span></code>, any instance declaration
in any module “below” <code class="docutils literal"><span class="pre">M</span></code> is visible. (Module <code class="docutils literal"><span class="pre">A</span></code> is “below” <code class="docutils literal"><span class="pre">M</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is
imported directly by <code class="docutils literal"><span class="pre">M</span></code>, or if <code class="docutils literal"><span class="pre">A</span></code> is below a module that <code class="docutils literal"><span class="pre">M</span></code> imports
directly.) In principle, GHC must therefore read the interface files of
every module below <code class="docutils literal"><span class="pre">M</span></code>, just in case they contain an instance declaration
that matters to <code class="docutils literal"><span class="pre">M</span></code>. This would be a disaster in practice, so GHC tries to
be clever.</p>
<p>In particular, if an instance declaration is in the same module as the
definition of any type or class mentioned in the <em>head</em> of the instance
declaration (the part after the “<code class="docutils literal"><span class="pre">=&gt;</span></code>”; see <a class="reference internal" href="glasgow_exts.html#instance-rules"><span class="std std-ref">Relaxed rules for instance contexts</span></a>), then GHC
has to visit that interface file anyway. Example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>
  <span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>The instance declaration is only relevant if the type <code class="docutils literal"><span class="pre">T</span></code> is in use, and
if so, GHC will have visited <code class="docutils literal"><span class="pre">A</span></code>’s interface file to find <code class="docutils literal"><span class="pre">T</span></code>’s definition.</p>
<p>The only problem comes when a module contains an instance declaration
and GHC has no other reason for visiting the module. Example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Orphan</span> <span class="kr">where</span>
  <span class="kr">instance</span> <span class="kt">C</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">D</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="o">...</span>
  <span class="kr">class</span> <span class="kt">C</span> <span class="n">a</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Here, neither <code class="docutils literal"><span class="pre">D</span></code> nor <code class="docutils literal"><span class="pre">T</span></code> is declared in module <code class="docutils literal"><span class="pre">Orphan</span></code>. We call such modules
“orphan modules”. GHC identifies orphan modules, and visits the
interface file of every orphan module below the module being compiled.
This is usually wasted work, but there is no avoiding it. You should
therefore do your best to have as few orphan modules as possible.</p>
<p>Functional dependencies complicate matters. Suppose we have:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">B</span> <span class="kr">where</span>
  <span class="kr">instance</span> <span class="kt">E</span> <span class="kt">T</span> <span class="kt">Int</span> <span class="kr">where</span> <span class="o">...</span>
  <span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Is this an orphan module? Apparently not, because <code class="docutils literal"><span class="pre">T</span></code> is declared in
the same module. But suppose class <code class="docutils literal"><span class="pre">E</span></code> had a functional dependency:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Lib</span> <span class="kr">where</span>
  <span class="kr">class</span> <span class="kt">E</span> <span class="n">x</span> <span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="kr">where</span> <span class="o">...</span>
</pre></div>
</div>
<p>Then in some importing module <code class="docutils literal"><span class="pre">M</span></code>, the constraint <code class="docutils literal"><span class="pre">(E</span> <span class="pre">a</span> <span class="pre">Int)</span></code> should be
“improved” by setting <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">T</span></code>, <em>even though there is no explicit
mention</em> of <code class="docutils literal"><span class="pre">T</span></code> in <code class="docutils literal"><span class="pre">M</span></code>.</p>
<p>These considerations lead to the following definition of an orphan
module:</p>
<ul>
<li><p class="first">An <em>orphan module</em> orphan module contains at least one <em>orphan
instance</em> or at least one <em>orphan rule</em>.</p>
</li>
<li><p class="first">An instance declaration in a module <code class="docutils literal"><span class="pre">M</span></code> is an <em>orphan instance</em> if
orphan instance</p>
<ul class="simple">
<li>The class of the instance declaration is not declared in <code class="docutils literal"><span class="pre">M</span></code>, and</li>
<li><em>Either</em> the class has no functional dependencies, and none of the
type constructors in the instance head is declared in <code class="docutils literal"><span class="pre">M</span></code>; <em>or</em>
there is a functional dependency for which none of the type
constructors mentioned in the <em>non-determined</em> part of the
instance head is defined in <code class="docutils literal"><span class="pre">M</span></code>.</li>
</ul>
<p>Only the instance head counts. In the example above, it is not good
enough for <code class="docutils literal"><span class="pre">C</span></code>’s declaration to be in module <code class="docutils literal"><span class="pre">A</span></code>; it must be the
declaration of <code class="docutils literal"><span class="pre">D</span></code> or <code class="docutils literal"><span class="pre">T</span></code>.</p>
</li>
<li><p class="first">A rewrite rule in a module <code class="docutils literal"><span class="pre">M</span></code> is an <em>orphan rule</em> orphan rule if none
of the variables, type constructors, or classes that are free in the
left hand side of the rule are declared in <code class="docutils literal"><span class="pre">M</span></code>.</p>
</li>
</ul>
<p>If you use the flag <a class="reference internal" href="using-warnings.html#ghc-flag--Worphans"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Worphans</span></code></a>, GHC will warn you if you are
creating an orphan module. Like any warning, you can switch the warning
off with <a class="reference internal" href="using-warnings.html#ghc-flag--Worphans"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wno-orphans</span></code></a>, and <a class="reference internal" href="using-warnings.html#ghc-flag--Werror"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Werror</span></code></a> will make
the compilation fail if the warning is issued.</p>
<p>You can identify an orphan module by looking in its interface file, <code class="docutils literal"><span class="pre">M.hi</span></code>,
using the <a class="reference internal" href="using.html#ghc-flag---show-iface ⟨file⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--show-iface</span> <span class="pre">⟨file⟩</span></code></a> <a class="reference internal" href="using.html#modes"><span class="std std-ref">mode</span></a>. If there is a
<code class="docutils literal"><span class="pre">[orphan</span> <span class="pre">module]</span></code> on the first line, GHC considers it an orphan module.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td>This is a change in behaviour relative to 6.2 and earlier.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="packages.html" title="7.9. Packages"
             >next</a> |</li>
        <li class="right" >
          <a href="runtime_control.html" title="7.7. Running a compiled program"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.5.20180310 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" >7. Using GHC</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>